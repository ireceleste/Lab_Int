import numpy as npfrom matplotlib import pyplot as pltimport pylabfrom scipy.optimize import curve_fitfrom scipy.stats import poisson# =============================================================================# Funzione per spacchettare i dati# =============================================================================def funzione_dati(t_input, ch):    """        Parameters    ----------    t_input : array di float        tempo in input dal file .dat    ch : array di 1 e 2        canale in cui si è registrato l'evento         Nota: t_input è preso direttamente dal contatore: dato che si riazzera in modo random    abbiamo fatto un ciclo for per rendere sequenziali i tempi. A questo scopo abbiamo    creato un array T che contiene i tempi sistemati         Returns    -------    t1 : array di tempi del canale 1    t2 : array di tempi del canale 2    tc : array di tempi in cui si è registrata una coincidenza tra canale 1 e 2        registra i tempi per cui il canale 1 e 2 sono scattati a un delta t Delta_t_coinc    """    t1=np.array([])    t2=np.array([])    tc= np.array([])    t=t_input        Delta_t_contatore =0.01 #s : tempo approssimativo tra una misura e l'altra     # quando il contatore si riazzera -  è circa il tau dell'istogramma dei delta t    Delta_t_coinc = 100e-9 #s        # ciclo for per sistemare i dati per i tempi    T=np.array([t[0]])    for i in range(1, len(t)):        if(i>0 and t[i-1]<t[i]):            T = np.append(T, t[i])        elif(i>0 and t[i]<t[i-1]):            T = np.append(T, t[i-1]+ Delta_t_contatore)            t=t+t[i-1]-t[i]        #ciclo for per spacchettare i tempi tra canale 1 e 2 e per registrare le coincidenze    for i in range(len(T)-1):        if (ch[i]==2):             t2=np.append(t2, T[i])        else:            t1=np.append(t1, T[i])        if((ch[i+1]!= ch[i]) and (abs(T[i]-T[i+1])<Delta_t_coinc)):             tc=np.append(tc, T[i])    return t1, t2, tc# =============================================================================# Funzione per creare un istogramma degli eventi nel tempo# =============================================================================def istogramma_tempi(t, nbins, numero_figura, ref_istogramma, numero_acquisizione=1,save_fig = False, nome_figura=None, **kwargs_histo):    """        Parameters    ----------    t : array dei tempi    nbins : numero di bins per l'istogramma dei tempi    numero_figura : numero della figura in cui andrà l'istogramma    ref_istogramma : stringa da mettere nel titolo su che istogramma è    numero_acquisizione : indice della misura (default 1)    Returns    -------    n_t : numero di conteggi in ogni bin    rate_t : rate dei conteggi per ogni bin di t        array che contiene il numero di eventi registrati in ogni bin temporale         diviso per la larghezza dell'intervallo temporale'    """        plt.figure(numero_figura)    plt.title(f'Istogramma {ref_istogramma} - acquisizione {numero_acquisizione}')    plt.ylabel('Numero di eventi')    plt.xlabel('Tempo [s]')    plt.xlim([0,3000])    n_t, bins, patches = plt.hist(t, nbins, **kwargs_histo)    Delta_t=bins[10]-bins[9]    rate_t=n_t/Delta_t #sistemati in modo che siano conteggi al secondo        indici = n_t>0    mean_bins = np.array([(bins[i]+bins[i+1])/2 for i in range(len(bins)-1)])    n_tot = sum(n_t)    if save_fig:       plt.savefig(nome_figura)        print("Numero totale conteggi ", ref_istogramma, f" = {n_tot} ")    return n_t, rate_t, Delta_t, mean_bins[indici]# =============================================================================# Istogramma pdf conteggi al secondo e analisi # =============================================================================def fit_function(n, mu):    return poisson.pmf(n, mu)def analisi_cps(counts, Delta_t, numero_figura, ref_istogramma, numero_acquisizione=1, save_fig = False, nome_figura=None):    """        Parameters    ----------    counts : array di conteggi        contiene i conteggi restituiti dall'istogramma per i tempi    Delta_t : float        intervallo temporale corrispondente ai conteggi: rate = counts/delta_t.    numero_figura : numero della figura che verrà creata    ref_istogramma : specifiche dell'istogramma nel titolo della figura    numero_acquisizione : int, optional        Numero di riferimento dell'acquisizione. The default is 1.    save_fig : bool, optional        se True, la figura viene salvata. The default is False.    nome_figura : string, optional        nome del file in cui verrà salvata la figura. The default is None.                Returns    -------    mu_cps : float        media della poissoniana uscita dal fit divisa per delta_t: dà la media del rate    sigma_mu_cps : float         errore sulla media della poissoniana uscita dal fit divisa per delta_t: dà la sigma della media del rate.    """    bins_semiinteri = np.arange(0, int(max(counts))+1, 1) - 0.5    occorrenze_rate, bins = np.histogram(counts, bins_semiinteri)        #preparazione dei dati per il fit: prendo la media dei bins (intera!) e     mean_bins = np.array([(bins[i]+bins[i+1])/2 for i in range(len(bins)-1)])            indici = occorrenze_rate>0    x = mean_bins[indici]    y=occorrenze_rate[indici]    occorrenze_totali = sum(y)    y = y/float(occorrenze_totali)        mu_fit, var_mu = curve_fit(fit_function, x, y, p0=np.mean(counts))    sigma_mu_fit = np.sqrt(var_mu.diagonal())[0]    #sigma_mu_fit = np.sqrt(mu_fit[0])    mu_cps = mu_fit[0]/Delta_t    sigma_mu_cps = sigma_mu_fit/Delta_t    print(f"Media della poissoniana: rate = {mu_cps:.3f} pm {sigma_mu_fit:.3f}")    # Grafico istogramma conteggi al secondo        plt.figure(numero_figura)    plt.title(f'Istogramma {ref_istogramma} - acquisizione {numero_acquisizione}')    plt.ylabel('Occorrenze')    plt.xlabel('Conteggi al secondo')        plt.bar( x/Delta_t, occorrenze_rate[indici], width = 1/Delta_t, align='center', label='Istogramma' ,alpha = 0.9)    #plt.plot(x/Delta_t, occorrenze_rate[indici], '.')    x_plot = np.arange(0, max(counts)+1, 1)    plt.plot(x_plot/Delta_t,fit_function(x_plot, mu_fit)*occorrenze_totali, ls = '-', label='Fit', color='red')    plt.legend(loc='best')        if save_fig:        plt.savefig(nome_figura)        return mu_cps, sigma_mu_cps# =============================================================================# Istogramma delle differenze di tempo tra un evento e l'altro# =============================================================================def fit_function_expo(t, A, l):    return A*np.exp(-t*l)def analisi_delta_t(t, numero_figura, ref_istogramma, numero_acquisizione=1, save_fig = False, nome_figura=None):    t_next = np.array([t[i+1] for i in range(len(t)-1)])    t_before = t[:-1]    Delta_t = t_next-t_before        plt.figure(numero_figura)    plt.title(f'Istogramma {ref_istogramma} - acquisizione {numero_acquisizione}')    plt.ylabel('Numero di eventi')    plt.xlabel('Delta tempo tra eventi [s]')    counts, bins, patches = plt.hist(Delta_t, 100)    # fit esponenziale     mean_bins = np.array([(bins[i]+bins[i+1])/2 for i in range(len(bins)-1)])    x = mean_bins    y = counts        #plt.plot(x,y, '*', color='k')        popt, pcov = curve_fit(fit_function_expo, x, y)    lambda_fit = popt[1]    sigma_lambda_fit = np.sqrt(pcov[1][1])        tau_fit = 1/lambda_fit    sigma_tau_fit = sigma_lambda_fit/lambda_fit**2        print("Lambda del fit ", ref_istogramma, f"= {lambda_fit:.3f} pm {sigma_lambda_fit:.3f} eventi al secondo")    print("Tau del fit" , ref_istogramma,f"= {tau_fit:.3f} pm {sigma_tau_fit:.3f} s")        x_plot = np.linspace(0, max(x), 1000)    y_plot = fit_function_expo(x_plot,*popt)    plt.plot(x_plot, y_plot, ls='-', label = 'Fit')    if save_fig:       plt.savefig("Grafici/"+ nome_figura)       # =============================================================================# Prima acquisizione di prova# =============================================================================n_acquis=0nbins = 5000ch, t= np.loadtxt('Dati/sciami_291122_prova4.dat', unpack='True')t1, t2, tc= funzione_dati(t, ch)n_t1, rate_t1 , Delta_t1, bins_t1= istogramma_tempi(t1, nbins, n_acquis+1, ref_istogramma="telescopio 1")n_t2, rate_t2, Delta_t2, bins_t2 = istogramma_tempi(t2, nbins, n_acquis+2, ref_istogramma="telescopio 2")n_tc, rate_tc, Delta_tc, bins_tc = istogramma_tempi(tc, 50, n_acquis+3, ref_istogramma="coincidenze")# Fit dell'istogramma dei conteggi di eventi per unità di tempo per i due canalirate1, drate1 = analisi_cps(n_t1, Delta_t1, numero_figura= n_acquis+4, ref_istogramma="eventi telescopio 1")rate2, drate2 = analisi_cps(n_t2,Delta_t2, numero_figura= n_acquis+5, ref_istogramma="eventi telescopio 2")# Fit delle differenze di tempo tra un evento e l'altroanalisi_delta_t(t1, n_acquis+6, ref_istogramma="delta t telescopio 1", save_fig=True, nome_figura="ist_dtempi_tel1")analisi_delta_t(t2, n_acquis+7, ref_istogramma="delta t telescopio 2", save_fig=True, nome_figura="ist_dtempi_tel2")